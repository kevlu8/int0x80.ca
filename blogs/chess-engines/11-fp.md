---
title: "11 - Moveloop pruning"
slug: fp
description: "Skipping unlikely moves"
date: 2025-07-04
---

# Moveloop Pruning
### 2025-07-04

Our engine is now at a decent level. But, if you look closely, you will see that it still searches a lot of moves that are kind of not worth searching. For example, a move that hangs our queen at the very end of the move list is still being searched.

This is where we use *moveloop pruning*. Moveloop pruning is a technique (applied near the horizon) where we skip searching moves that are unlikely to improve our score, instead of skipping nodes directly.

We should not apply moveloop pruning in situations where we haven't yet found a move that doesn't lose (i.e. a non-mated move). This is to avoid misevaluating positions as mates when in fact we're pruning off our only escape.

## Futility Pruning

Futility pruning skips over quiet moves when our static evaluation is below alpha by a significant amount. Essentially, quiet moves are unlikely to swing evaluation by a large amount, so we can skip them to speed up our search.

```cpp
if (best > -VALUE_MATE_MAX_PLY) {
	Value futility = static_eval + 300 + 100 * depth;
	if (!in_check && !capt && !promo && depth <= 5 && futility <= alpha)
		continue;
}
```

These values generally work well, but make sure to tune them for your engine!

```
Elo   | 6.27 +- 4.15 (95%)
SPRT  | 8.0+0.08s Threads=1 Hash=32MB
LLR   | 2.91 (-2.25, 2.89) [0.00, 5.00]
Games | N: 7482 W: 1780 L: 1645 D: 4057
Penta | [28, 858, 1839, 983, 33]
```
https://sscg13.pythonanywhere.com/test/1809/

## Late Move Pruning

Similar to futility pruning, we can also skip searching moves that are ordered near the very back of our move list. This is called late move pruning (LMP)!

```cpp
if (best > -VALUE_MATE_MAX_PLY) {
	if (m_idx > 5 + 2 * depth * depth)
		continue;

	... // futility pruning goes after
}
```

It's pretty intuitive and not too difficult to implement. You can play around with the formula to find which one works best for you. Stronger engines reduce the formula as much as `3 + depth * depth`, but for our purposes, this should be sufficient.

```
Elo   | 8.09 +- 5.07 (95%)
SPRT  | 8.0+0.08s Threads=1 Hash=32MB
LLR   | 2.90 (-2.25, 2.89) [0.00, 5.00]
Games | N: 6226 W: 1568 L: 1423 D: 3235
Penta | [78, 681, 1461, 804, 89]
```
https://sscg13.pythonanywhere.com/test/548/

## History Pruning

We've been using history tables for move ordering so far, but we can also use them to prune off some moves! Essentially, if a move has a really terrible history value, we can skip it, since it has consistently not been a good move.

```cpp
if (history[board.side][move.from()][move.to()] < -2000 * depth) continue;
```

It really doesn't get much simpler than this.

```
Elo   | 20.82 +- 8.48 (95%)
SPRT  | 8.0+0.08s Threads=1 Hash=32MB
LLR   | 2.94 (-2.25, 2.89) [0.00, 5.00]
Games | N: 2122 W: 556 L: 429 D: 1137
Penta | [18, 207, 494, 314, 28]
```
https://sscg13.pythonanywhere.com/test/562/
